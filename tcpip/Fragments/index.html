<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fragments (tcpip.Fragments)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">tcpip</a> &#x00BB; Fragments</nav><header class="odoc-preamble"><h1>Module <code><span>Fragments</span></code></h1><p>IPv4 Fragmentation and reassembly</p><p>An IPv4 packet may exceed the maximum transferable unit (MTU) of a link, and thus may be fragmented into multiple packets. Since the MTU depends on the underlying link, fragmentation and reassembly may happen in gateways as well as endpoints. Starting at byte 6, 16 bit in the IPv4 header are used for fragmentation. The first bit is reserved, the second signals if set to never fragment this packet - instead if it needs to be fragmented, an ICMP error must be returned (used for path MTU discovery). The third bit indicates whether this is the last fragment or more are following. The remaining 13 bits are the offset of this fragment in the reassembled packet, divided by 8. All fragments of one reassembled packet use the same 16 bit IPv4 identifier (byte offset 4). The IPv4 header is repeated in each fragment, apart from those options which highest bit is cleared. Fragments may be received in any order.</p><p>This module implements a reassembly cache, using a least recently used (LRU) cache underneath. For security reasons, only non-overlapping fragments are accepted. To avoid denial of service attacks, the maximum number of segments is limited to 16 - with a common MTU of 1500, this means that packets exceeding 24000 bytes will be dropped. The arrival time of the first and last fragment may not exceed 10 seconds. There is no per-source IP limit of fragment data to keep, only the total amount of fragmented data can be limited by the choice of the size of the LRU.</p><p>Any received packet may be the last needed for a successful reassembly (due to receiving them out-of-order). When the last fragment (which has the more fragments bit cleared) for a quadruple source IP, destination IP, IP identifier, and protocol ID, is received, reassembly is attempted - also on subsequent packets with the same quadruple.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-V"><a href="#module-V" class="anchor"></a><code><span><span class="keyword">module</span> <a href="V/index.html">V</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-K"><a href="#module-K" class="anchor"></a><code><span><span class="keyword">module</span> <a href="K/index.html">K</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Cache"><a href="#module-Cache" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cache/index.html">Cache</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-max_duration"><a href="#val-max_duration" class="anchor"></a><code><span><span class="keyword">val</span> max_duration : int64</span></code></div><div class="spec-doc"><p><code>max_duration</code> is the maximum delta between first and last received fragment, in nanoseconds. At the moment it is 10 seconds.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-process"><a href="#val-process" class="anchor"></a><code><span><span class="keyword">val</span> process : 
  <span><a href="Cache/index.html#type-t">Cache.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int64 <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ipv4_packet/index.html#type-t">Ipv4_packet.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Cstruct</span>.t <span class="arrow">&#45;&gt;</span></span>
  <a href="Cache/index.html#type-t">Cache.t</a> * <span><span>(<a href="../Ipv4_packet/index.html#type-t">Ipv4_packet.t</a> * <span class="xref-unresolved">Cstruct</span>.t)</span> option</span></span></code></div><div class="spec-doc"><p><code>process t timestamp hdr payload</code> is <code>t'</code>, a new cache, and maybe a fully reassembled IPv4 packet. If reassembly fails, e.g. too many fragments, delta between receive timestamp of first and last packet exceeds <a href="#val-max_duration"><code>max_duration</code></a>, overlapping packets, these packets will be dropped from the cache. The IPv4 header options are always taken from the first fragment (where offset is 0). If the provided IPv4 header has an fragmentation offset of 0, and the more fragments bit is not set, the given header and payload is directly returned. Handles out-of-order fragments gracefully.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fragment"><a href="#val-fragment" class="anchor"></a><code><span><span class="keyword">val</span> fragment : <span><span class="label">mtu</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ipv4_packet/index.html#type-t">Ipv4_packet.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Cstruct</span>.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Cstruct</span>.t list</span></span></code></div><div class="spec-doc"><p><code>fragment ~mtu hdr payload</code> is called with the IPv4 header of the first fragment and the remaining payload (which did not fit into the first fragment). The <code>data_length = ((mtu - header_length hdr) / 8) * 8</code> is used for each fragment (and it is assumed that the first fragment contains exactly that much data). The number of packets returned is <code>len payload / data_len</code>. If <code>data_len &lt;= 0</code>, the empty list is returned.</p></div></div></div></body></html>
